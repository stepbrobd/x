diff --git i/src/libflake/flake.cc w/src/libflake/flake.cc
index 486118963..10583e909 100644
--- i/src/libflake/flake.cc
+++ w/src/libflake/flake.cc
@@ -24,15 +24,14 @@ using namespace flake;
 
 namespace flake {
 
-static void forceTrivialValue(EvalState & state, Value & value, const PosIdx pos)
+static void forceValueDeep(EvalState & state, Value & value, const PosIdx pos)
 {
-    if (value.isThunk() && value.isTrivial())
-        state.forceValue(value, pos);
+    state.forceValue(value, pos);
 }
 
 static void expectType(EvalState & state, ValueType type, Value & value, const PosIdx pos)
 {
-    forceTrivialValue(state, value, pos);
+    forceValueDeep(state, value, pos);
     if (value.type() != type)
         throw Error("expected %s but got %s at %s", showType(type), showType(value.type()), state.positions[pos]);
 }
@@ -47,6 +46,8 @@ static std::pair<std::map<FlakeId, FlakeInput>, fetchers::Attrs> parseFlakeInput
 
 static void parseFlakeInputAttr(EvalState & state, const Attr & attr, fetchers::Attrs & attrs)
 {
+    state.forceValue(*attr.value, attr.pos);
+
 // Allow selecting a subset of enum values
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wswitch-enum"
@@ -106,7 +107,7 @@ static FlakeInput parseFlakeInput(
     for (auto & attr : *value->attrs()) {
         try {
             if (attr.name == sUrl) {
-                forceTrivialValue(state, *attr.value, pos);
+                forceValueDeep(state, *attr.value, pos);
                 if (attr.value->type() == nString)
                     url = attr.value->string_view();
                 else if (attr.value->type() == nPath) {
@@ -206,9 +207,14 @@ static Flake readFlake(
     auto flakeDir = rootDir / CanonPath(resolvedRef.subdir);
     auto flakePath = flakeDir / "flake.nix";
 
-    // NOTE evalFile forces vInfo to be an attrset because mustBeTrivial is true.
+    // Allow arbitrary complexity
     Value vInfo;
-    state.evalFile(flakePath, vInfo, true);
+    state.evalFile(flakePath, vInfo, false);
+    state.forceValue(vInfo, noPos);
+
+    if (vInfo.type() != nAttrs)
+        throw Error("flake.nix must evaluate to an attribute set, got %s at %s",
+                    showType(vInfo.type()), flakePath);
 
     Flake flake{
         .originalRef = originalRef,
@@ -225,6 +231,7 @@ static Flake readFlake(
     auto sInputs = state.symbols.create("inputs");
 
     if (auto inputs = vInfo.attrs()->get(sInputs)) {
+        state.forceValue(*inputs->value, inputs->pos);
         auto [flakeInputs, selfAttrs] =
             parseFlakeInputs(state, inputs->value, inputs->pos, lockRootAttrPath, flakeDir, true);
         flake.inputs = std::move(flakeInputs);
@@ -234,6 +241,7 @@ static Flake readFlake(
     auto sOutputs = state.symbols.create("outputs");
 
     if (auto outputs = vInfo.attrs()->get(sOutputs)) {
+        state.forceValue(*outputs->value, outputs->pos);
         expectType(state, nFunction, *outputs->value, outputs->pos);
 
         if (outputs->value->isLambda() && outputs->value->lambda().fun->hasFormals()) {
@@ -251,10 +259,11 @@ static Flake readFlake(
     auto sNixConfig = state.symbols.create("nixConfig");
 
     if (auto nixConfig = vInfo.attrs()->get(sNixConfig)) {
+        state.forceValue(*nixConfig->value, nixConfig->pos);
         expectType(state, nAttrs, *nixConfig->value, nixConfig->pos);
 
         for (auto & setting : *nixConfig->value->attrs()) {
-            forceTrivialValue(state, *setting.value, setting.pos);
+            forceValueDeep(state, *setting.value, setting.pos);
             if (setting.value->type() == nString)
                 flake.config.settings.emplace(
                     state.symbols[setting.name], std::string(state.forceStringNoCtx(*setting.value, setting.pos, "")));
